### 核心概念

#### 1.分片

分库分表一般是指水平切分模式（水平分库、分表）为基础（**任务系统是水平分库**），将一张数据量较大的表t_order拆分为多个表结构完全一致的小数据量t_order_0,t_order_1....t_order_n。每张表只存储一部分数据，当执行sql时会通过分库策略，分片策略将数据分散到不同的数据库、表内。

#### 2.数据节点

数据节点是分库分表中一个不可再分的最小数据单元，它有数据源名称和数据表组成，例如上面的order_db_1.t_order_0就表示一个数据节点。

#### 3.逻辑表

逻辑表是指一组具有相同逻辑和数据结构表的总称。比如我们将订单表t_order拆分成t_order_0...t_order_9等十张表，此时我们会发现分库分表以后我们数据库不存在t_order这张表，取而代之的是t_order_n，但我们在写代码时写sql依然按t_order来写，此时t_order就是这些拆分表的逻辑表。

#### 4.真实表

真实表也就是上边提到的 t_order_n 数据库中真实存在的物理表。

#### 5.分片键

用于分片的数据库字段，将t_order表分片以后，当执行sql时，通过对字段order_id取模的方式来决定，这条数据该在哪个数据库中的哪个表中执行，此时order_id字段就是t_order表中的分片键。

####  6.分片算法

上面提到可以使用分片键取模的规则来进行分片，还可以使用>=,<=,>,< between和in作为分片规则，自定义分片逻辑，这时候就需要用到分片策略和分片算法。

分库分表可以认为是一种路由机制，将sql语句路由到我们期望的数据库或数据表中，分片算法可以理解成路由规则。

分片策略知识一种抽象概念，分片策略有分片键和分片算法组成。每种策略中可以使多个分片算法的组合，每个分片算法可以对多个分片分片键做逻辑判断。

**注意**：sharding-jdbc 并没有直接提供分片算法的实现，需要开发者根据业务自行实现

#### sharding-jdbc默认的四种分片算法

1. **精确分片算法（PreciseShardingAlgorithm）**：使用单个字段作为分片键，sql中有=与in等条件的分片，需要在标准分片策略（StandardShardingStrategy）下使用
2. **范围分片算法（RangeShardingAlgorithm）**：用于单子字段作为分片键，sql中有beetween and,>,<,>=,<=,等条件的分片，需要在标准分片策略(StandardShardingStrategy)下使用。
3. **复合分片算法（ComplexKeysShardingAlgorithm）**：用于多个字段作为分片键的分片操作，同时获取到多个分片键的值，根据多个字段处理业务逻辑。需要在复合分片策略下使用。
4. **Hint分片算法（HintShardingAlgorithm）**：上面的算法都是通过解析sql语句提取分片键，并设置分片策略进行分片。但有时候我们并没有使用任何的分片键和分片策略。可还想将sql路由到目标数据库和表，就需要通过手动干预指定sql的目标数据库和表信息，这叫强制路由。

####  7.分片策略

-  **标准分片策略（StandardShardingStrategy）**：次策略支持**精确分片算法（PreciseShardingAlgorithm）**和**范围分片算法（RangeShardingAlgorithm）**

  其中PreciseShardingAlgorithm是必选的，用于处理=和in的分片。RanageShardingAlgorithm是可选的，用于处理BEETWEEN AND,>,<,>=,<=条件分片，如果不配置RanageShardingAlgorithm，sql中的条件将按照全库路由处理。

- **复合分片策略：**复合分片策略，同样支持对 SQL语句中的 =，>， <， >=， <=，IN和 BETWEEN AND 的分片操作。不同的是它支持多分片键，具体分配片细节完全由应用开发者实现。

- **行表达式分片策略：** 行表达式分片策略，支持对 SQL语句中的 = 和 IN 的分片操作，但只支持单分片键。这种策略通常用于简单的分片，不需要自定义分片算法，可以直接在配置文件中接着写规则。

  t_order_$->{t_order_id % 4} 代表 t_order 对其字段 t_order_id取模，拆分成4张表，而表名分别是t_order_0 到 t_order_3。

- **Hint 分片策略**： Hint 分片策略，对应上边的 Hint 分片算法，通过指定分片健而非从 SQL 中提取分片健的方式进行分片的策略。

#### 8.分布式主键

数据分⽚后，不同数据节点⽣成全局唯⼀主键是⾮常棘⼿的问题，同⼀个逻辑表（t_order）内的不同真实表（t_order_n）之间的⾃增键由于⽆法互相感知而产⽣重复主键。

尽管可通过设置⾃增主键 初始值 和 步⻓ 的⽅式避免 ID 碰撞，但这样会使维护成本加大，乏完整性和可扩展性。如果后去需要增加分片表的数量，要逐一修改分片表的步长，运维成本非常高，所以不建议这种方式。

实现分布式主键⽣成器的方式很多，可以参考我之前写的《9种分布式ID生成方式》。

为了让上手更加简单，ApacheShardingSphere 内置了 UUID、SNOWFLAKE 两种分布式主键⽣成器，默认使⽤雪花算法（snowflake）⽣成 64bit 的⻓整型数据。不仅如此它还抽离出分布式主键⽣成器的接口，⽅便我们实现⾃定义的⾃增主键⽣成算法。

#### 9.广播表

存在于所有的分片数据源中的表，表结构和表中的数据在每个数据库中均完全一致。一般是为字典表或者配置表 t_config，某个表一旦被配置为广播表，只要修改某个数据库的广播表，所有数据源中广播表的数据都会跟着同步。

#### 10.绑定表

那些分片规则一致的主表和子表。比如：t_order 订单表和 t_order_item 订单服务项目表，都是按 order_id 字段分片，因此两张表互为绑定表关系。

那绑定表存在的意义是啥呢？

通常在我们的业务中都会使用 t_order 和 t_order_item 等表进行多表联合查询，但由于分库分表以后这些表被拆分成N多个子表。如果不配置绑定表关系，会出现笛卡尔积关联查询，

而配置绑定表关系后再进行关联查询时，只要对应表分片规则一致产生的数据就会落到同一个库中，那么只需 t_order_0 和 t_order_item_0 表关联即可。

**注意**：在关联查询时 t_order 它作为整个联合查询的主表。所有相关的路由计算都只使用主表的策略，t_order_item 表的分片相关的计算也会使用 t_order 的条件，所以要保证绑定表之间的分片键要完全相同。


Sharding-JDBC 分库分表-分页查询优化方案
Sharding-JDBC的优化
（1）采用流式处理 + 归并排序的方式来避免内存的过量占用。由于SQL改写不可避免的占用了额外的带宽，但并不会导致内存暴涨。 与直觉不同，大多数人认为Sharding-JDBC会将1,000,010 * 2记录全部加载至内存，进而占用大量内存而导致内存溢出。 但由于每个结果集的记录是有序的，因此Sharding-JDBC每次仅获取各个分片的当前结果集记录，驻留在内存中的记录仅为当前路由到的分片的结果集的当前游标指向而已。 对于本身即有序的待排序对象，归并排序的时间复杂度仅为O(n)，性能损耗很小。
Sharding-JDBC对仅落至单分片的查询进行进一步优化。 落至单分片查询的请求并不需要改写SQL也可以保证记录的正确性，因此在此种情况下，Sharding-JDBC并未进行SQL改写，从而达到节省带宽的目的。

互联网公司常用分库分表方案汇总！
1、sharding-sphere：jar，前身是sharding-jdbc；
2、TDDL：jar，Taobao Distribute Data Layer；
3、mycat 中间件


选用sharding-jdbc原因
1. mycat比较重, 相对于sharding-jdbc只需导入jar包就行, mycat还需要部署维护一个中间件服务.由于我们只有一个表需要分表, 直接用轻量级的sharding-jdbc即可.
2. mycat作为一个中间代理服务, 难免有性能损耗




3.6方案对比
目前主流的分库分表方案就是sharding-jdbc和mycat,为此做了一个对比

Sharding-jdbc	Mycat
工作层面	JDBC 协议	MySQL 协议/JDBC 协议
运行方式	Jar 包， 客户端	独立服务， 服务端
开发方式	代码/配置改动	连接地址（数据源）
运维方式	无	管理独立服务， 运维成本高
性能	多线程并发按操作， 性能高	独立服务+网络开销， 存在性能损失风险
功能范围	协议层面	包括分布式事务、 数据迁移等
适用操作	OLTP	OLTP+OLAP
支持数据库	基于 JDBC 协议的数据库	MySQL 和其他支持 JDBC 协议的数据库
支持语言	Java 项目中使用	支持 JDBC 协议的语言
动态调整数据源	需自己实现	添加新组合配置并重启mycat