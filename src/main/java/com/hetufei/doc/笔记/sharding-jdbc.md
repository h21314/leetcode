### 核心概念

#### 1.分片

分库分表一般是指水平切分模式（水平分库、分表）为基础（**任务系统是水平分库**），将一张数据量较大的表t_order拆分为多个表结构完全一致的小数据量t_order_0,t_order_1....t_order_n。每张表只存储一部分数据，当执行sql时会通过分库策略，分片策略将数据分散到不同的数据库、表内。

#### 2.数据节点

数据节点是分库分表中一个不可再分的最小数据单元，它有数据源名称和数据表组成，例如上面的order_db_1.t_order_0就表示一个数据节点。

#### 3.逻辑表

逻辑表是指一组具有相同逻辑和数据结构表的总称。比如我们将订单表t_order拆分成t_order_0...t_order_9等十张表，此时我们会发现分库分表以后我们数据库不存在t_order这张表，取而代之的是t_order_n，但我们在写代码时写sql依然按t_order来写，此时t_order就是这些拆分表的逻辑表。

#### 4.真实表

真实表也就是上边提到的 t_order_n 数据库中真实存在的物理表。

#### 5.分片键

用于分片的数据库字段，将t_order表分片以后，当执行sql时，通过对字段order_id取模的方式来决定，这条数据该在哪个数据库中的哪个表中执行，此时order_id字段就是t_order表中的分片键。

####  6.分片算法

上面提到可以使用分片键取模的规则来进行分片，还可以使用>=,<=,>,< between和in作为分片规则，自定义分片逻辑，这时候就需要用到分片策略和分片算法。

分库分表可以认为是一种路由机制，将sql语句路由到我们期望的数据库或数据表中，分片算法可以理解成路由规则。

分片策略知识一种抽象概念，分片策略有分片键和分片算法组成。每种策略中可以使多个分片算法的组合，每个分片算法可以对多个分片分片键做逻辑判断。

**注意**：sharding-jdbc 并没有直接提供分片算法的实现，需要开发者根据业务自行实现

#### sharding-jdbc默认的四种分片算法

1. **精确分片算法（PreciseShardingAlgorithm）**：使用单个字段作为分片键，sql中有=与in等条件的分片，需要在标准分片策略（StandardShardingStrategy）下使用
2. **范围分片算法（RangeShardingAlgorithm）**：用于单子字段作为分片键，sql中有beetween and,>,<,>=,<=,等条件的分片，需要在标准分片策略(StandardShardingStrategy)下使用。
3. **复合分片算法（ComplexKeysShardingAlgorithm）**：用于多个字段作为分片键的分片操作，同时获取到多个分片键的值，根据多个字段处理业务逻辑。需要在复合分片策略下使用。
4. **Hint分片算法（HintShardingAlgorithm）**：上面的算法都是通过解析sql语句提取分片键，并设置分片策略进行分片。但有时候我们并没有使用任何的分片键和分片策略。可还想将sql路由到目标数据库和表，就需要通过手动干预指定sql的目标数据库和表信息，这叫强制路由。

####  7.分片策略

-  **标准分片策略（StandardShardingStrategy）**：次策略支持**精确分片算法（PreciseShardingAlgorithm）**和**范围分片算法（RangeShardingAlgorithm）**

  其中PreciseShardingAlgorithm是必选的，用于处理=和in的分片。RanageShardingAlgorithm是可选的，用于处理BEETWEEN AND,>,<,>=,<=条件分片，如果不配置RanageShardingAlgorithm，sql中的条件将按照全库路由处理。

- **复合分片策略：**复合分片策略，同样支持对 SQL语句中的 =，>， <， >=， <=，IN和 BETWEEN AND 的分片操作。不同的是它支持多分片键，具体分配片细节完全由应用开发者实现。

- **行表达式分片策略：** 行表达式分片策略，支持对 SQL语句中的 = 和 IN 的分片操作，但只支持单分片键。这种策略通常用于简单的分片，不需要自定义分片算法，可以直接在配置文件中接着写规则。

  t_order_$->{t_order_id % 4} 代表 t_order 对其字段 t_order_id取模，拆分成4张表，而表名分别是t_order_0 到 t_order_3。

- **Hint 分片策略**： Hint 分片策略，对应上边的 Hint 分片算法，通过指定分片健而非从 SQL 中提取分片健的方式进行分片的策略。

#### 8.分布式主键

数据分⽚后，不同数据节点⽣成全局唯⼀主键是⾮常棘⼿的问题，同⼀个逻辑表（t_order）内的不同真实表（t_order_n）之间的⾃增键由于⽆法互相感知而产⽣重复主键。

尽管可通过设置⾃增主键 初始值 和 步⻓ 的⽅式避免 ID 碰撞，但这样会使维护成本加大，乏完整性和可扩展性。如果后去需要增加分片表的数量，要逐一修改分片表的步长，运维成本非常高，所以不建议这种方式。

实现分布式主键⽣成器的方式很多，可以参考我之前写的《9种分布式ID生成方式》。

为了让上手更加简单，ApacheShardingSphere 内置了 UUID、SNOWFLAKE 两种分布式主键⽣成器，默认使⽤雪花算法（snowflake）⽣成 64bit 的⻓整型数据。不仅如此它还抽离出分布式主键⽣成器的接口，⽅便我们实现⾃定义的⾃增主键⽣成算法。

#### 9.广播表

存在于所有的分片数据源中的表，表结构和表中的数据在每个数据库中均完全一致。一般是为字典表或者配置表 t_config，某个表一旦被配置为广播表，只要修改某个数据库的广播表，所有数据源中广播表的数据都会跟着同步。

#### 10.绑定表

那些分片规则一致的主表和子表。比如：t_order 订单表和 t_order_item 订单服务项目表，都是按 order_id 字段分片，因此两张表互为绑定表关系。

那绑定表存在的意义是啥呢？

通常在我们的业务中都会使用 t_order 和 t_order_item 等表进行多表联合查询，但由于分库分表以后这些表被拆分成N多个子表。如果不配置绑定表关系，会出现笛卡尔积关联查询，

而配置绑定表关系后再进行关联查询时，只要对应表分片规则一致产生的数据就会落到同一个库中，那么只需 t_order_0 和 t_order_item_0 表关联即可。

**注意**：在关联查询时 t_order 它作为整个联合查询的主表。所有相关的路由计算都只使用主表的策略，t_order_item 表的分片相关的计算也会使用 t_order 的条件，所以要保证绑定表之间的分片键要完全相同。