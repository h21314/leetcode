undo log 一致性
redo 持久性
binlog 一般用于数据恢复
### 1.innodb和myisaim区别
> 事务、行锁，外键、聚集索引，非聚集索引
innodb:支持事务，支持外键，最新版本支持全文索引、支持行锁，页级锁，表级锁。支持聚簇索引，索引就是数据，顺序存储。读写组设与事务隔离级别有关
myisam：使用非聚簇索引，索引和文件是分开的。读写互相阻塞，读读之间不阻塞。
### 为什么myisam查询比innodb快？
因为innodb在select时维护的东西比myisam多
##### 2.为什么使用b+树索引，索引结构，与b树的区别是
b+树只有叶子节点存数据，b+树查询效率比较稳定。b+树每页能存更多的索引，b树非叶子节点也会存储数据。
b+树范围查询比b树简单
##### 3.事务的隔离级别，不同的隔离级别可能存在的问题，以及如何解决
读未提交 不会使用到mvcc机制
读已提交 会使用到mvcc机制，select时每个事物读的都是最新的Read view
可重复读 会使用mvcc机制，select时对每个事物都会开启一个Readview，每个事物读的都是自己的那个视图
串行化

事务隔离级别实现原理？
使用MVCC多版本并发控制的方式来解决不可重复读，实现读写不冲突。使用行锁来解决并发写的问题。解决幻读是使用间隙锁。行锁和间隙锁组成next-key锁，解决幻读的问题。
在事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。当事务A执行update user set name='风筝2号’ where age = 10; 的时候，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。不仅插入 age = 10 的记录需要等待事务A提交，age<10、10<age<30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。

这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。

##### 持久性的原理，redo日志
##### mvcc多版本控制，
实现了读不加锁，读写不冲突
> 只在读以提交和可重复读生效，
读已提交：每一次select时都会生成一个视图；每次执行语句的时候都重新生成一次快照
可重复读：第一次select时生成一个view，后续select都用这个view。在事务开始时生成一个当前事务全局性的快照

mvcc会在每一行上都生成两个隐藏列trx_id，roll_pointer，row_id；trx_id是顺序自增的

参考文章：https://blog.csdn.net/SnailMann/article/details/94724197
##### 出现慢sql如何排查
1、可能是cpu负载高
2、IO高
3、慢sql
 4、如果数据量过大，需要考虑进一步的分库分表
##### 索引优化
最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整；

=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式；

尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录；

索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

##### explain各个字段的含义
1、select_type：A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个
              
              B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个
              
              C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union
              
              D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响
              
              E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null
              
              F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery
              
              G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响
              
              H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select
2、table：
3、type：依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引
4、A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index
  
  B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描
  
  C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref
  
  D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。
  
  E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引
  
  F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。
  
  G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值
  
  H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。
  
  I：range：索引范围扫描，常见于使用>,<,is null,between ,in ,like等运算符的查询中。
  
  J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range
  
  K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。
  
  L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。
4、possible_keys：查询可能使用到的索引都会在这里列出来
5、key：查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。
6、key_len:用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。
7、ref：如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func
8、rows
  

##### 如何保证mysql的高可用，
> 主备、读写分离
主从复制原理：

>
##### 分库分表实现方案
垂直、水平
##### 数据库锁有哪几种
乐观锁、悲观锁、
页锁，表锁，行锁、间隙锁、next key lock = 间隙锁 + 行锁
##### 如何设计动态扩容的分库分表方案
> 停机扩容（不推荐）倍数扩容
>
##### 采用分库分表后历史数据如何迁移
> 编写程序同步历史数据，再利用mq进行双写操作
##### 用过哪些分库分表中间件,有啥优点和缺点,
##### 分片策略
- 标准分片策略（StandardShardingStrategy）它只支持对单个分片健（字段）为依据的分库分表，并提供了两种分片算法 PreciseShardingAlgorithm（精准分片）和 RangeShardingAlgorithm（范围分片）。
- 复合分片策略、SQL 语句中有>，>=, <=，<，=，IN 和 BETWEEN AND 等操作符，不同的是复合分片策略支持对多个分片健操作，自定义复合分片策略要实现 ComplexKeysShardingAlgorithm 接口，重新 doSharding()方法。

- 行表达式分片策略（InlineShardingStrategy）提供对 SQL语句中的 = 和 IN 的分片操作支持，它只支持单分片健。行表达式分片策略适用于做简单的分片算法，无需自定义分片算法，省去了繁琐的代码开发，是几种分片策略中最为简单的
- Hint分片策略 
> Hint分片策略（HintShardingStrategy）相比于上面几种分片策略稍有不同，这种分片策略无需配置分片健，分片健值也不再从 SQL中解析，而是由外部指定分片信息，让 SQL在指定的分库、分表中执行。ShardingSphere 通过 Hint API实现指定操作，实际上就是把分片规则tablerule 、databaserule由集中配置变成了个性化配置。
           举个例子，如果我们希望订单表t_order用 user_id 做分片健进行分库分表，但是 t_order 表中却没有 user_id 这个字段，这时可以通过 Hint API 在外部手动指定分片健或分片库。


##### 聚簇索引和唯一索引区别
##### redolog undolog binlog区别
redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。

在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到WAL即Write Ahead logging技术，他的关键点是先写日志，再写磁盘。

有了redo log日志，那么在数据库进行异常重启的时候，可以根据redo log日志进行恢复，也就达到了crash-safe。

redo log日志的大小是固定的，即记录满了以后就从头循环写。

### mysql update语句执行流程
``
 UPDATE T SET age = age+1 WHERE id = 1;
``
1、客户端通过连接器与mysql相连。
2、删除要update表的缓存
3、mysql分析器解析sql并判断是否含有语句错误
4、优化器确定查询索引
5、执行器先找引擎找id=1这行记录。id为主键，引擎通过索引找到记录.(判断数据是否在内存中，在的话直接返回行数据，不在的话从磁盘中读取数据到内存中（读取一整页）)
6、执行器拿到行记录，对age+1，调用引擎写接口，更新数据；
7、引擎将新记录更新到内存，并将更新记录写入redo log，redo log处于prepare状态，随时可以提交事务；
10，执行器生成bin log写入磁盘；
11，执行器调用引擎提交事务接口，把redo log成成commit状态，更新完成。

innodb_flush_log_at_trx_commit设置为1，表示每次事务的redo log都直接持久化到磁盘，可以保证MySQL异常重启之后数据不丢失。

sync_binlog设置为1，表示每次事务的bin log都持久化到磁盘，可以保证MySQL异常重启之后bin log不丢失。
三、二阶段提交
为了让两份日志逻辑一致，上述操作使用了二阶段提交。

假设不使用二阶段提交，会有如下两种情况。

假设age = 10，使用之前的UPDATE SQL。

A.先写redo log，后写bin log；中间发生崩溃，通过redo log自动恢复数据，age = 11。但是因为bin log没有写入，如果用之前的数据进行恢复，age = 10。

B.先写bin log，后写redo log；中间发生崩溃，age = 10（未更新），使用bin log恢复，age = 11。

都会出现数据不一致的情况，使用二阶段提交，让两份日志数据保持逻辑上的一致。

为什么要使用二阶段提交？
答：反证法。
1、先写redo log后写binlog。假设redo log写完，binlog还没写完，mysql进程异常重启。由于我们前面说过的，redo log写完之后，系统及时崩溃了，仍然能够恢复数据。但由于binlog没写成功就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，然后你会发现，当需要用这个binlog日志来恢复数据时，由于这个binlog丢失，这个临时库就会少了这一次更新，导致数据丢失。
2、先写binlog再写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复之后这个事务无效，所以这一行c的值是0
；但是binlog里面已经记录了将c从0改为1的这条日志，所以，后序用binlog恢复的时候就多了一个事务出来，恢复后的数据就是1，与原库的值不同。
redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

具体update语句更新流程以及使用二阶段提交保证redo log和binlog日志保持逻辑上的一致相关知识可以参照
https://www.jianshu.com/p/c852253fd443



### MySql事务日志redo log和undo log区别
数据库存放数据的文件成为data file，日志文件称为log file；数据库数据是由缓存的，数据库缓存称为data buffer；日志缓存称为log buffer；既然存在缓存，就很难保证缓存数据与磁盘数据的一致性。
存储引擎会为redo undo日志开辟内存缓存空间（log buffer）。磁盘上的日志文件称为log file。是顺序追加的，性能很高。
undo 日志用于记录事务开始前的状态，用于事务失败时的回滚。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功的事务更新数据。
以下是事务执行的各个阶段：
1、写undo日志到log buffer
2、执行事务，并写redo日志到log buffer
3、如果innodb_flush_log_at_trx_commit = 1则将redo日志写到log file，并刷新磁盘
4、提交事务。
可能有同学会问，为什么没有写data file，事务就提交了？

在数据库的世界里，数据从来都不重要，日志才是最重要的，有了日志就有了一切。

 因为data buffer中的数据会在合适的时间 由存储引擎写入到data file，如果在写入之前，数据库宕机了，根据落盘的redo日志，完全可以将事务更改的数据恢复。好了，看出日志的重要性了吧。先持久化日志的策略叫做Write Ahead Log，即预写日志。

分析几种异常情况：

innodb_flush_log_at_trx_commit=2（innodb_flush_log_at_trx_commit和sync_binlog参数详解）时，将redo日志写入logfile后，为提升事务执行的性能，存储引擎并没有调用文件系统的sync操作，将日志落盘。如果此时宕机了，那么未落盘redo日志事务的数据是无法保证一致性的。
undo日志同样存在未落盘的情况，可能出现无法回滚的情况。
checkpoint：

 checkpoint是为了定期将db buffer的内容刷新到data file。当遇到内存不足、db buffer已满等情况时，需要将db buffer中的内容/部分内容（特别是脏数据）转储到data file中。在转储时，会记录checkpoint发生的”时刻“。在故障回复时候，只需要redo/undo最近的一次checkpoint之后的操作。
 
 ### redo log 和binlog日志的区别
 - binlog是在存储引擎的上层产生的，不管是什么存储引擎，只要对数据库进行了修改都会产生binlog日志。而redo log是innodb层产生的，只记录该存储引擎中表的修改。并且二进制文件先于redo log被记录。
 - binlog记录逻辑性的语句。即它是基于行格式的记录方式，其本质是逻辑的sql设置。而redo log是在物理格式上的日志，记录的是数据库中每个页的修改
 - binlog只在每次事务提交时一次性写入缓存中的日志文件。而redo log在事物中就会产生，并且在数据真正修改前先写入缓存中的redo log，然后才对内存中的数据执行修改操作；而且保证在事物提交时，先向缓存中的redo log写入到redo log file
 中，redo log file写入完成后才执行提交动作。
 - 因为binlog只在提交时一次性写入，所以binlog日志中记录方式和提交顺序有关，且一次提交对应一次记录。而redo log是记录的物理页的修改，redo log file中同一个事物可能多次记录，最后一个提交的事务会覆盖所有未提交的事务记录。
 例如事务T1，可能在redo log中记录了 T1-1,T1- 2,T1-3，T1* 共4个操作，其中 T1* 表示最后提交时的日志记录，所以对应的数据页最终状态是 T1* 对应的操作结果。而且redo log是并发写入的，不同事务之间的不同版本的记录会穿插写入到redo log文件中，例如可能redo log的记录方式如下： T1-1,T1-2,T2-1,T2- 2,T2,T1-3,T1 。

redo log用来保证事务的持久性。redo log可以分为物理redo 日志和逻辑redo 日志。在InnoDB存储引擎中，大部分情况下 Redo是物理日志，记录的是数据页的物理变化。
逻辑Redo日志，不记录页面的实际修改内容，而只记录修改页面的一类操作，比如新建数据页。关于逻辑Redo日志涉及更加底层的内容，这里我们只需要记住绝大数情况下，Redo是物理日志即可，DML对页的修改操作，均需要记录Redo。

redo的主要作用是用于数据库的崩溃恢复
#### redo组成：
redo log buffer 在内存中，易失
redo log file 在磁盘中，是持久性的。


### .MySQL间隙锁为了解决什么问题，什么条件下会触发?
产生条件：
1、使用普通索引锁定
2、使用多列唯一索引
3、使用唯一索引锁定多行记录
为了在可重复读隔离级别下解决幻读。间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其他事务在这个区间内插入修改删除数据。
对于操作的数据是主键索引和普通索引，有不同的加锁规则。
1、唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁时，只会加行锁，不会产生间隙锁
2、普通索引不管是锁单条还是多条记录，都会产生间隙锁。
### 幻读因为什么造成的?
事务A在插入时没有锁住相邻的记录，导致事物B插入了数据
### mysql的数据页空洞是怎么造成的，如果解决，索引是局部还是全局的
解决方案：可以进行表的重建：alter table
### mysql如果发生了抖动，怎么排查问题?

### mysql 锁相关知识。
https://blog.csdn.net/weixin_39600510/article/details/110865954



### mysql的主键自增用完了怎么办？


